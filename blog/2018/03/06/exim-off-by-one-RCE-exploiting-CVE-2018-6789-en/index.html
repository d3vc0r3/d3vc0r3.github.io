
<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="utf-8" />
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" />
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <title>Exim Off-by-one RCE: Exploiting CVE-2018-6789 with Fully Mitigations Bypassing | DEVCORE</title><link href="/assets/themes/devcore-v2/stylesheets/webpack_bundle.css" rel="stylesheet" />
    <link href="/assets/themes/devcore-v2/images/favicon.png" rel="icon" size="32x32">
    <meta name="description" property="og:description" content="We reported an overflow vulnerability in the base64 decode function of Exim on 5 February, 2018, identified as CVE-2018-6789. This bug exists since the first commit of exim, hence ALL versions are affected. According to our research, it can be leveraged to gain Pre-auth Remote Code Execution and at least 400k servers are at risk. Patched version 4.90.1 is already released and we suggest to upgrade exim immediately." />
    <meta name="keywords" content="Advisory, Exim, RCE, CVE" />
    <meta property="og:site_name" content="DEVCORE 戴夫寇爾" />
    <meta property="og:title" content="Exim Off-by-one RCE: Exploiting CVE-2018-6789 with Fully Mitigations Bypassing | DEVCORE 戴夫寇爾" />
    <meta property="og:url" content="https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://devco.re/assets/img/blog/20180306/cover.png" />
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="d3vc0r3">
    <meta name="twitter:title" content="Exim Off-by-one RCE: Exploiting CVE-2018-6789 with Fully Mitigations Bypassing | DEVCORE 戴夫寇爾">
    <meta name="twitter:description" content="We reported an overflow vulnerability in the base64 decode function of Exim on 5 February, 2018, identified as CVE-2018-6789. This bug exists since the first commit of exim, hence ALL versions are affected. According to our research, it can be leveraged to gain Pre-auth Remote Code Execution and at least 400k servers are at risk. Patched version 4.90.1 is already released and we suggest to upgrade exim immediately.">
    <meta name="twitter:creator" content="d3vc0r3">
    <meta name="twitter:image:src" content="https://devco.re/assets/img/blog/20180306/cover.png">
    <meta name="twitter:domain" content="devco.re">
    <meta name="google-site-verification" content="lMNi_XT6UmeGqeYI_vLHu5PDRi_uNVfnA2NdDGS4-lM" />
    <meta name="msvalidate.01" content="119FDBB7730BE45B162515BBB1FF6B33" />
    <meta name="alexaVerifyID" content="j-Es9N9SD7ckfA2EokOz9SZzhok" />
    <meta name='yandex-verification' content='4561963cf1d18fe3' />
    <meta property="fb:admins" content="120968921404653" />

    <link rel="canonical" href="https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/"/>
    <link rel="alternate" type="application/rss+xml" title="DEVCORE 戴夫寇爾" href="https://devco.re/rss">

    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-K5B8NW');</script>
    <!-- End Google Tag Manager -->
  </head>
  <body>
    <div class="page">
      <div class="container--wrapper">
        <div class="topbar">
          <div class="topbar__brand">
            <a href="/en/">
                <div class="logo">
                  DEVCORE
                </div></a>
            <p class="slogan">
              We offer professional <a href="/en/services/penetration-test" class="link">pentesting</a>, <a href="/en/services/red-team" class="link">red teaming</a>, <a href="/en/services/security-consulting" class="link">consulting</a>, and <a href="/en/services/security-training" class="link">training</a> services
            </p>
          </div>
          <div class="drawer" id="drawer">
            <div class="drawer__container">
              <nav class="main-menu">
                <div class="hidden">
                  Menu
                </div>
                <a href="/en/services/penetration-test" class="main-menu__link mobile-only">Penetration Testing</a>
                <a href="/en/services/red-team" class="main-menu__link mobile-only">Red Team Assessment</a>
                <a href="/en/services/security-consulting" class="main-menu__link mobile-only">Consulting</a>
                <a href="/en/services/security-training" class="main-menu__link mobile-only">Training</a>
                <a href="/en/about/" class="main-menu__link">Hackers</a><a href="/en/blog/" class="main-menu__link">News</a><a href="/en/search/" class="main-menu__link main-menu__search desktop-only"><span class="hidden">Search</span><svg class="icon-search icon"><use xlink:href="#icon-search" /></svg></a>
              </nav>
              <a href="/en/contact/" class="drawer__contact button--dense">Contact</a>
              <nav class="lang-menu">
                <div class="lang-menu__label">
                  Lang:
                </div>
                <a href="/" class="lang-menu__link">中文</a>
                <a href="/en/" class="lang-menu__link">English</a>
              </nav>
            </div>
          </div><span class="topbar__menu mobile-only">menu</span><button class="appearance-none topbar__hamburger mobile-only" data-toggle="#drawer" id="drawer-toggle" type="button">
            <div class="bars">
              <div class="bar"></div>
              <div class="bar"></div>
              <div class="bar"></div>
            </div>
          </button>
        </div>
      </div><main role="main">


          <div class="container--wrapper">
            <div class="container">
              <section class="blog-header">
                <small class="blog-header__category"><a href="/en/blog/category/Tech Editorials/" style="text-transform: uppercase;">Tech Editorials</a></small>
                <img src="https://devco.re/assets/img/blog/20180306/cover.png" class="blog-header__image" alt="Exim Off-by-one RCE: Exploiting CVE-2018-6789 with Fully Mitigations Bypassing" />
                <h1 class="blog-header__title">
                  Exim Off-by-one RCE: Exploiting CVE-2018-6789 with Fully Mitigations Bypassing
                </h1>
                <div class="blog-header__tags">
                  
                  <a href="/en/blog/tag/Advisory/" class="blog-header__tag">Advisory</a><a href="/en/blog/tag/Exim/" class="blog-header__tag">Exim</a><a href="/en/blog/tag/RCE/" class="blog-header__tag">RCE</a><a href="/en/blog/tag/CVE/" class="blog-header__tag">CVE</a>
                </div>
          
          
                <p class="blog-header__info">
                  By <span class="blog-author-photo" style="background-image: url(/assets/themes/devcore-v2/images/avatar/meh.jpg)"></span> <a href="/en/blog/author/meh" class="author-name">Meh</a> <time class="date">on 2018-03-06 </time>
                </p>
          
              </section>
              <article class="article">
          <h2 id="overview">Overview</h2>
<p>We reported an overflow vulnerability in the base64 decode function of <a href="https://www.exim.org/"><strong>Exim</strong></a> on 5 February, 2018, identified as <a href="https://exim.org/static/doc/security/CVE-2018-6789.txt">CVE-2018-6789</a>. This bug exists since the first commit of exim, hence <strong>ALL versions</strong> are affected. According to our research, it can be leveraged to gain <strong>Pre-auth Remote Code Execution</strong> and at least 400k servers are at risk. Patched version 4.90.1 is already released and we suggest to upgrade exim immediately.</p>

<h2 id="affected">Affected</h2>
<ul>
  <li>All Exim versions below 4.90.1</li>
</ul>

<h1 id="one-byte-overflow-in-base64-decoding">One byte overflow in base64 decoding</h1>

<h3 id="vulnerability-analysis">Vulnerability Analysis</h3>

<p>This is a calculation mistake of decode buffer length in <code class="highlighter-rouge">b64decode</code> function:<br />
<a href="https://github.com/Exim/exim/blob/master/src/src/base64.c#L153">base64.c: 153 b64decode</a></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b64decode</span><span class="p">(</span><span class="k">const</span> <span class="n">uschar</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="n">uschar</span> <span class="o">**</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="n">uschar</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">store_get</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">Ustrlen</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
<span class="c1">// perform decoding</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As shown above, exim allocates a buffer of <code class="highlighter-rouge">3*(len/4)+1</code> bytes to store decoded base64 data. However, when the input is not a valid base64 string and the length is <code class="highlighter-rouge">4n+3</code>, exim allocates <code class="highlighter-rouge">3n+1</code> but consumes <code class="highlighter-rouge">3n+2</code> bytes while decoding. This causes one byte heap overflow (aka off-by-one).<br />
Generally, this bug is harmless because the memory overwritten is usually unused. However, this byte overwrites some critical data when the string fits some specific length. In addition, this byte is controllable, which makes exploitation more feasible.<br />
Base64 decoding is such a fundamental function and therefore this bug can be triggered easily, causing remote code execution.<br />
<a id="back"></a></p>

<h3 id="exploitation">Exploitation</h3>
<p>To estimate the severity of this bug, we developed an exploit targeting SMTP daemon of exim. The exploitation mechanism used to achieve pre-auth remote code execution is described in the following paragraphs. In order to leverage this one byte overflow, it is necessary to trick memory management mechanism. It is highly recommended to have basic knowledge of heap exploitation <a href="#heap_exp">[ref]</a> before reading this section.</p>

<p>We developed the exploit with:</p>
<ul>
  <li><strong>Debian(stretch)</strong> and <strong>Ubuntu(zesty)</strong></li>
  <li><strong>SMTP daemon of Exim4 package</strong> installed with apt-get (4.89/4.88)</li>
  <li>Config enabled (uncommented in default config) <strong>CRAM-MD5 authenticator</strong> (any other authenticator using base64 also works)</li>
  <li>Basic SMTP commands (<strong>EHLO, MAIL FROM/RCPT TO</strong>) and <strong>AUTH</strong></li>
</ul>

<h4 id="memory-allocation">Memory allocation</h4>

<p>First, we review the source code and search for useful memory allocation. As we mentioned in the <a href="">previous article</a>, exim uses self-defined functions for dynamic allocation:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="n">BOOL</span>    <span class="n">store_extend_3</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>  <span class="cm">/* The */</span>
<span class="k">extern</span> <span class="kt">void</span>    <span class="n">store_free_3</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>     <span class="cm">/* value of the */</span>
<span class="k">extern</span> <span class="kt">void</span>   <span class="o">*</span><span class="n">store_get_3</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>         <span class="cm">/* 2nd arg is   */</span>
<span class="k">extern</span> <span class="kt">void</span>   <span class="o">*</span><span class="n">store_get_perm_3</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>    <span class="cm">/* __FILE__ in  */</span>
<span class="k">extern</span> <span class="kt">void</span>   <span class="o">*</span><span class="n">store_malloc_3</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>      <span class="cm">/* every call,  */</span>
<span class="k">extern</span> <span class="kt">void</span>    <span class="n">store_release_3</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>  <span class="cm">/* so give its  */</span>
<span class="k">extern</span> <span class="kt">void</span>    <span class="n">store_reset_3</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>    <span class="cm">/* correct type */</span>
</code></pre></div></div>
<p>Function <code class="highlighter-rouge">store_free()</code> and <code class="highlighter-rouge">store_malloc()</code> calls <code class="highlighter-rouge">malloc()</code> and <code class="highlighter-rouge">free()</code> of glibc directly. Glibc takes a slightly bigger (<code class="highlighter-rouge">0x10</code> bytes) <strong>chunk</strong> and stores its metadata in the first <code class="highlighter-rouge">0x10</code> bytes (x86-64) on every allocation, and then returns the location of <code class="highlighter-rouge">data</code>. The following illustration describes structure of chunk:<br />
<img src="/assets/img/blog/20180306/1.png" alt="" /></p>

<p>Metadata includes size of previous chunk (the one exactly above in memory), size of current block and some flags. The first three bits of <code class="highlighter-rouge">size</code> are used to store flags. In this example, size of <code class="highlighter-rouge">0x81</code> implies current chunk is <code class="highlighter-rouge">0x80</code> bytes and the previous chunk is in use.<br />
Most of released chunks used in exim are put into a doubly linked list called <strong>unsorted bin</strong>. Glibc maintains it according to the flags, and merges adjacent released chunks into a bigger chunk to avoid fragmentation. For every allocation request, glibc checks these chunks in an FIFO (first in, first-out) order and reuses the chunks.</p>

<p>For some performance issues, exim maintains its own linked list structure with <code class="highlighter-rouge">store_get()</code>, <code class="highlighter-rouge">store_release()</code>, <code class="highlighter-rouge">store_extend()</code> and <code class="highlighter-rouge">store_reset()</code>.<br />
<img src="/assets/img/blog/20180306/2.png" alt="architecture of storeblock" /><br />
The main feature of storeblocks is that every block is at least <code class="highlighter-rouge">0x2000</code> bytes, which becomes a restriction to our exploitation. Note that a storeblock is also the <code class="highlighter-rouge">data</code> of a chunk. Therefore, if we look into the memory, it is like:<br />
<img src="/assets/img/blog/20180306/3.png" alt="" /></p>

<p>Here we list functions used to arrange heap data:</p>

<ul>
  <li>EHLO hostname<br />
  For each EHLO(or HELO) command, exim stores the pointer of hostname in <code class="highlighter-rouge">sender_host_name</code>.
    <ul>
      <li><code class="highlighter-rouge">store_free()</code> old name</li>
      <li><code class="highlighter-rouge">store_malloc()</code> for new name</li>
    </ul>

    <p><a href="https://github.com/Exim/exim/blob/master/src/src/smtp_in.c#L1833">smtp_in.c: 1833 check_helo</a></p>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="mi">1839</span> <span class="cm">/* Discard any previous helo name */</span>
  <span class="mi">1840</span>
  <span class="mi">1841</span> <span class="k">if</span> <span class="p">(</span><span class="n">sender_helo_name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="mi">1842</span>   <span class="p">{</span>
  <span class="mi">1843</span>   <span class="n">store_free</span><span class="p">(</span><span class="n">sender_helo_name</span><span class="p">);</span>
  <span class="mi">1844</span>   <span class="n">sender_helo_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="mi">1845</span>   <span class="p">}</span>
  <span class="p">...</span>
  <span class="mi">1884</span> <span class="k">if</span> <span class="p">(</span><span class="n">yield</span><span class="p">)</span> <span class="n">sender_helo_name</span> <span class="o">=</span> <span class="n">string_copy_malloc</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
  <span class="mi">1885</span> <span class="k">return</span> <span class="n">yield</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>Unrecognized command<br />
  For every unrecognized command with unprintable characters, exim allocates a buffer to convert it to printable
    <ul>
      <li><code class="highlighter-rouge">store_get()</code> to store error message</li>
    </ul>

    <p><a href="https://github.com/Exim/exim/blob/master/src/src/smtp_in.c#L5725">smtp_in.c: 5725 smtp_setup_msg</a></p>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="mi">5725</span>   <span class="n">done</span> <span class="o">=</span> <span class="n">synprot_error</span><span class="p">(</span><span class="n">L_smtp_syntax_error</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
  <span class="mi">5726</span>     <span class="n">US</span><span class="s">"unrecognized command"</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>AUTH<br />
  In most authentication procedure, exim uses base64 encoding to communicate with client. The encode and decode string are stored in a buffer allocated by <code class="highlighter-rouge">store_get()</code>.
    <ul>
      <li><code class="highlighter-rouge">store_get()</code> for strings</li>
      <li>can contain unprintable characters, NULL bytes</li>
      <li>not necessarily null terminated</li>
    </ul>
  </li>
  <li>Reset in EHLO/HELO, MAIL, RCPT<br />
  When a command is done correctly, <code class="highlighter-rouge">smtp_reset()</code> is called. This function calls <code class="highlighter-rouge">store_reset()</code> to reset block chain to a <strong>reset point</strong>, which means all storeblocks allocated by <code class="highlighter-rouge">store_get()</code> after last command are released.
    <ul>
      <li><code class="highlighter-rouge">store_reset()</code> to reset point (set at the beginning of function)</li>
      <li>release blocks added at a time</li>
    </ul>

    <p><a href="https://github.com/Exim/exim/blob/master/src/src/smtp_in.c#L3771">smtp_in.c: 3771 smtp_setup_msg</a></p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  3771 int
  3772 smtp_setup_msg(void)
  3773 {
  3774 int done = 0;
  3775 BOOL toomany = FALSE;
  3776 BOOL discarded = FALSE;
  3777 BOOL last_was_rej_mail = FALSE;
  3778 BOOL last_was_rcpt = FALSE;
  3779 void *reset_point = store_get(0);
  3780
  3781 DEBUG(D_receive) debug_printf("smtp_setup_msg entered\n");
  3782
  3783 /* Reset for start of new message. We allow one RSET not to be counted as a
  3784 nonmail command, for those MTAs that insist on sending it between every
  3785 message. Ditto for EHLO/HELO and for STARTTLS, to allow for going in and out of
  3786 TLS between messages (an Exim client may do this if it has messages queued up
  3787 for the host). Note: we do NOT reset AUTH at this point. */
  3788
  3789 smtp_reset(reset_point);
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="exploit-steps">Exploit steps</h4>
<p>To leverage this off-by-one, the chunk beneath decoded base64 data should be freed easily and controllable. After several attempts, we found that <code class="highlighter-rouge">sender_host_name</code> is a better choice. We arrange the heap layout to leave a freed chunk above <code class="highlighter-rouge">sender_host_name</code> for the base64 data.<br />
<img src="/assets/img/blog/20180306/4.png" alt="" /></p>

<ol>
  <li>
    <p>Put a huge chunk into unsorted bin<br />
 First of all, we send a EHLO message with huge hostname to make it allocate and deallocate, leaving a <code class="highlighter-rouge">0x6060</code> length (3 storeblocks long) chunk in unsorted bin.</p>
  </li>
  <li>
    <p>Cut the first storeblock<br />
 Then we send an unrecognized string to trigger <code class="highlighter-rouge">store_get()</code> and allocate a storeblock inside the freed chunk.</p>
  </li>
  <li>
    <p>Cut the second storeblock and release the first one<br />
 We send a EHLO message again to get the second storeblock. The first block is freed sequentially because of the <code class="highlighter-rouge">smtp_reset</code> called after EHLO is done.</p>

    <p>After the heap layout is prepared, we can use the off-by-one to overwrite the original chunk size. We modify <code class="highlighter-rouge">0x2021</code> to <code class="highlighter-rouge">0x20f1</code>, which slightly extends the chunk.</p>

    <p><img src="/assets/img/blog/20180306/5.png" alt="" /></p>
  </li>
  <li>
    <p>Send base64 data and trigger off-by-one<br />
 To trigger off-by-one, we start an AUTH command to send base64 data. The overflow byte precisely overwrites the first byte of next chunk and extends the next chunk.</p>
  </li>
  <li>
    <p>Forge a reasonable chunk size<br />
 Because the chunk is extended, the start of next chunk of is changed to somewhere inside of the original one. Therefore, we need to make it <strong>seems like</strong> a normal chunk to pass sanity checks in glibc. We send another base64 string here, because it requires <code class="highlighter-rouge">NULL</code> byte and unprintable character to forge chunk size.</p>
  </li>
  <li>
    <p>Release the extended chunk<br />
 To control the content of extended chunk, we need to release the chunk first because we cannot edit it directly. That is, we should send a new EHLO message to release the old host name. However, normal EHLO message calls <code class="highlighter-rouge">smtp_reset</code> after it succeeds, which possibly makes program abort or crash. To avoid this, we send an <strong>invalid</strong> host name such as <code class="highlighter-rouge">a+</code>.</p>
  </li>
  <li>
    <p>Overwrite the <strong><code class="highlighter-rouge">next</code></strong> pointer of overlapped storeblock</p>

    <p><img src="/assets/img/blog/20180306/6.png" alt="" /><br />
 After the chunk is released, we can retrieve it with AUTH and overwrite part of overlapped storeblock. Here we use a trick called <strong>partial write</strong>. With this, we can modify the pointer without breaking <strong>ASLR</strong> (Address space layout randomization). We partially changed the <code class="highlighter-rouge">next</code> pointer to a storeblock containing ACL (Access Control List) strings. The ACL strings are pointed by a set of global pointers such as:</p>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">uschar</span> <span class="o">*</span><span class="n">acl_smtp_auth</span><span class="p">;</span>
 <span class="n">uschar</span> <span class="o">*</span><span class="n">acl_smtp_data</span><span class="p">;</span>
 <span class="n">uschar</span> <span class="o">*</span><span class="n">acl_smtp_etrn</span><span class="p">;</span>
 <span class="n">uschar</span> <span class="o">*</span><span class="n">acl_smtp_expn</span><span class="p">;</span>
 <span class="n">uschar</span> <span class="o">*</span><span class="n">acl_smtp_helo</span><span class="p">;</span>
 <span class="n">uschar</span> <span class="o">*</span><span class="n">acl_smtp_mail</span><span class="p">;</span>
 <span class="n">uschar</span> <span class="o">*</span><span class="n">acl_smtp_quit</span><span class="p">;</span>
 <span class="n">uschar</span> <span class="o">*</span><span class="n">acl_smtp_rcpt</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>These pointers are initialized at the beginning of exim process, set according to the configure. For example, if there is a line <code class="highlighter-rouge">acl_smtp_mail = acl_check_mail</code> in the configure, the pointer <code class="highlighter-rouge">acl_smtp_mail</code> points to the string <code class="highlighter-rouge">acl_check_mail</code>. Whenever MAIL FROM is used, exim performs an ACL check, which expands <code class="highlighter-rouge">acl_check_mail</code> first. While expanding, exim tries to execute commands if it encounters <code class="highlighter-rouge">${run{cmd}}</code>, so we achieve code execution as long as we control the ACL strings. In addition, we do not need to hijack program control flow directly and therefore we can bypass mitigations such as <strong>PIE</strong> (Position Independent Executables), <strong>NX</strong> easily.</p>
  </li>
  <li>
    <p>Reset storeblocks and retrieve the ACL storeblock<br />
 Now the ACL storeblock is in the linked list chain. It will be released once <code class="highlighter-rouge">smtp_reset()</code> is triggered, and then we can retrieve it again by allocating multiple blocks.</p>
  </li>
  <li>
    <p>Overwrite ACL strings and trigger ACL check<br />
 Finally, we overwrite the whole block containing ACL strings. Now we send commands such as EHLO, MAIL, RCPT to trigger ACL checks. Once we touch an acl defined in the configure, we achieve remote code execution.</p>
  </li>
</ol>

<h2 id="fix">Fix</h2>
<p>Upgrade to 4.90.1 or above</p>

<h2 id="timeline">Timeline</h2>

<ul>
  <li>5 February, 2018 09:10 Reported to Exim</li>
  <li>6 February, 2018 23:23 CVE received</li>
  <li>10 February, 2018 18:00 Patch released</li>
</ul>

<h2 id="credits">Credits</h2>
<p>Vulnerabilities found by Meh, DEVCORE research team.<br />
meh [at] devco [dot] re</p>

<h2 id="reference">Reference</h2>

<p>https://exim.org/static/doc/security/CVE-2018-6789.txt<br />
https://git.exim.org/exim.git/commit/cf3cd306062a08969c41a1cdd32c6855f1abecf1<br />
https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-6789<br />
http://www.openwall.com/lists/oss-security/2018/02/07/2</p>

<p><a id="heap_exp"></a></p>
<h4 id="heap-exploitation-materials-return">Heap exploitation materials <a href="#back">[return]</a></h4>
<ul>
  <li><a href="https://heap-exploitation.dhavalkapil.com/">Heap Exploitation</a>: A tutorial of heap exploitation by Dhaval Kapil</li>
  <li><a href="https://github.com/shellphish/how2heap">how2heap</a>: A repo for learning heap exploitation by Shellphish</li>
  <li><a href="https://www.slideshare.net/AngelBoy1/heap-exploitation-51891400">Heap exploitation</a>: (Chinese) A slide introducing basic glibc heap exploitation by Angelboy</li>
  <li><a href="https://www.slideshare.net/AngelBoy1/advanced-heap-exploitaion">Advanced heap exploitation</a>: (Chinese) A slide of advanced heap exploitation techniques by Angelboy</li>
  <li><a href="https://googleprojectzero.blogspot.tw/2014/08/the-poisoned-nul-byte-2014-edition.html">The poisoned NUL byte</a>: An article of Null byte off-by-one exploitation by Project Zero</li>
</ul>


              </article>
              <p class="sns-widgets">
                Share this on <button class="appearance-none sns-widgets__button" id="sns-facebook" type="button">Facebook</button> or <button class="appearance-none sns-widgets__button" id="sns-twitter" type="button">Twitter</button>
              </p>
          
              <div class="heading--side-lined">
                About <span class="blog-author-photo" style="background-image: url(/assets/themes/devcore-v2/images/avatar/meh.jpg)"></span> <a href="/en/blog/author/meh" class="blog-author-name">Meh</a> 
              </div>
              <p class="blog-author-info">
                I am a pwner.
              </p>
          
              <div class="heading--side-lined">
                Comments
              </div>
              <div class="blog-comments">
                


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'd3vc0r3'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




              </div>
            </div>
          </div>






</main>
      <div class="container--wrapper">


        <div class="contact-section container">
          <h2 class="contact-section__title">
            Put your defenses to the test with authentic attacks
          </h2>
          <a href="/en/contact/" class="home-contact__button button--dense">Contact us now</a>
        </div>

        <footer class="main-footer">
          <div class="main-footer__about">
            DEVCORE offers professional<br class="mobile-only" /><a href="/en/services/penetration-test" class="link">pentesting</a>, <a href="/en/services/red-team" class="link">red teaming</a>, <a href="/en/services/security-consulting" class="link">consulting</a>, and <a href="/en/services/security-training" class="link">training</a> services.<br />For <a href="/en/blog/" class="link">latest updates</a>, follow us on <a href="https://www.facebook.com/D3VC0RE" class="link" target="_blank">Facebook</a> or <a href="https://twitter.com/d3vc0r3" class="link" target="_blank">Twitter</a>.
          </div>
          <div class="main-footer__snses"><a href="https://www.facebook.com/D3VC0RE" class="main-footer__sns" target="_blank">
                <svg class="icon-fb icon"><use xlink:href="#icon-fb" /></svg></a><a href="https://twitter.com/d3vc0r3" class="main-footer__sns" target="_blank">
                <svg class="icon-twitter icon"><use xlink:href="#icon-twitter" /></svg></a>
          </div>
          <address class="main-footer__address">
            <ul class="list--unstyled">
              <li>
                13F., No. 32, Sec. 3, Bade Rd., Songshan Dist., Taipei City 105608, Taiwan
              </li>
              <li>
                contact@devco.re
              </li>
              <li>
                +886-2-2577-0925
              </li>
            </ul>
          </address><small class="main-footer__copyright"><a href="/" class="logo">DEVCORE</a>©2023 DEVCORE</small>
        </footer>
      </div>
    </div>
    <script src="/assets/themes/devcore-v2/javascripts/webpack_bundle.js"></script>



  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-30830800-1']);
  _gaq.push(['_trackPageview', location.pathname + location.search + location.hash]);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>




    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K5B8NW"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

  </body>
</html>




